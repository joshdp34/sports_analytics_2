[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STA 3311 Sports Analytics II",
    "section": "",
    "text": "Introduction\nThese are the lecture notes for STA 3311 - Sports Analytics II.\nPrerequisites: STA 3310 - Sports Analytics I\n\nCourse Description:\nDelves deeper into sports analytics, emphasizing sophisticated statistical models and data manipulation techniques to refine predictions and strategies in sports settings."
  },
  {
    "objectID": "01_Intro.html#using-mutate-to-add-or-transform-variables",
    "href": "01_Intro.html#using-mutate-to-add-or-transform-variables",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.1 Using mutate() to Add or Transform Variables",
    "text": "1.1 Using mutate() to Add or Transform Variables\nThe mutate() function in dplyr is an essential tool for creating new variables or modifying existing ones in a dataset. In the context of sports analytics, this function is particularly useful when you want to compute new metrics or adjust raw data into more meaningful forms. For example, a player’s raw performance statistics, such as hits or points scored, can be transformed into ratios or averages, providing more insightful performance measures such as batting averages or efficiency ratings.\n\n1.1.1 Syntax\nThe basic syntax of mutate() is as follows:\nmutate(data, new_variable = expression)\nHere, data is the name of the dataset you are working with, new_variable is the name of the variable you are adding or modifying, and expression is the formula used to calculate the value of the new variable.\nWe can also use the pipe operator as follows:\ndata |&gt; \nmutate(new_variable = expression)\n\n\n1.1.2 Why Use mutate()?\nIn sports analytics, it is often necessary to create variables that represent metrics or statistics derived from existing data. For example:\n\nCreating a new variable that represents a player’s scoring efficiency.\nCalculating a team’s win rate by dividing the number of wins by the total number of games played.\nComputing advanced metrics such as player efficiency rating (PER) in basketball or on-base plus slugging (OPS) in baseball.\n\nBy transforming raw data into meaningful statistics, you can uncover new insights that are not immediately apparent in the original dataset.\n\nExample 1.1 (Calculating Batting Average) Let’s begin with a basic example using data from the Lahman package, which contains Major League Baseball (MLB) statistics. We will calculate each player’s batting average (BA), a widely used performance metric that represents the ratio of a player’s hits (H) to at-bats (AB).\n\nlibrary(tidyverse)\nlibrary(Lahman)\n\n# Example: Adding Batting Average (BA) to Batting data\nbatting_data = Batting |&gt;\n  mutate(BA = H / AB)\n\nhead(batting_data)\n\n   playerID yearID stint teamID lgID  G  AB  R  H X2B X3B HR RBI SB CS BB SO\n1 abercda01   1871     1    TRO   NA  1   4  0  0   0   0  0   0  0  0  0  0\n2  addybo01   1871     1    RC1   NA 25 118 30 32   6   0  0  13  8  1  4  0\n3 allisar01   1871     1    CL1   NA 29 137 28 40   4   5  0  19  3  1  2  5\n4 allisdo01   1871     1    WS3   NA 27 133 28 44  10   2  2  27  1  1  0  2\n5 ansonca01   1871     1    RC1   NA 25 120 29 39  11   3  0  16  6  2  2  1\n6 armstbo01   1871     1    FW1   NA 12  49  9 11   2   1  0   5  0  1  0  1\n  IBB HBP SH SF GIDP        BA\n1  NA  NA NA NA    0 0.0000000\n2  NA  NA NA NA    0 0.2711864\n3  NA  NA NA NA    1 0.2919708\n4  NA  NA NA NA    0 0.3308271\n5  NA  NA NA NA    0 0.3250000\n6  NA  NA NA NA    0 0.2244898\n\n\nIn this example, we use mutate() to create a new variable BA, which stores the batting average for each player. This new column is derived from dividing the number of hits (H) by the number of at-bats (AB).\n\n\n\n1.1.3 Handling Missing Values with mutate()\nIn some cases, you may encounter missing or undefined values in your dataset. When using mutate() to create new variables, it’s important to handle these missing values to avoid errors or incorrect calculations. In R, you can use the na.rm = TRUE argument in relevant functions (like sum() or mean()) to remove missing values before performing calculations.\n\nExample 1.2 (Handling division by zero) Let’s modify the batting average calculation to handle cases where the number of at-bats (AB) is zero, which would otherwise lead to a division by zero error.\n\nbatting_data = Batting |&gt;\n  mutate(BA = ifelse(AB == 0, NA, H / AB))\n\nhead(batting_data)\n\n   playerID yearID stint teamID lgID  G  AB  R  H X2B X3B HR RBI SB CS BB SO\n1 abercda01   1871     1    TRO   NA  1   4  0  0   0   0  0   0  0  0  0  0\n2  addybo01   1871     1    RC1   NA 25 118 30 32   6   0  0  13  8  1  4  0\n3 allisar01   1871     1    CL1   NA 29 137 28 40   4   5  0  19  3  1  2  5\n4 allisdo01   1871     1    WS3   NA 27 133 28 44  10   2  2  27  1  1  0  2\n5 ansonca01   1871     1    RC1   NA 25 120 29 39  11   3  0  16  6  2  2  1\n6 armstbo01   1871     1    FW1   NA 12  49  9 11   2   1  0   5  0  1  0  1\n  IBB HBP SH SF GIDP        BA\n1  NA  NA NA NA    0 0.0000000\n2  NA  NA NA NA    0 0.2711864\n3  NA  NA NA NA    1 0.2919708\n4  NA  NA NA NA    0 0.3308271\n5  NA  NA NA NA    0 0.3250000\n6  NA  NA NA NA    0 0.2244898\n\n\nIn this case, we use ifelse() to check if a player has zero at-bats (AB == 0). If this condition is met, we assign a missing value (NA) to the batting average, otherwise, the batting average is calculated as usual.\n\n\n\n1.1.4 Multiple Transformations with mutate()\nThe mutate() function can be used to perform multiple transformations in a single call. This is useful when you need to create several new variables based on existing data. You can also overwrite existing variables if needed.\n\nExample 1.3 (Performing multiple transformations with mutate())  \n\nbatting_data = Batting |&gt;\n  mutate(BA = ifelse(AB == 0, NA, H / AB),\n         OBP = (H + BB + HBP) / (AB + BB + SF + HBP),\n         SLG = (H - X2B - X3B - HR + 2*X2B + 3*X3B + 4*HR) / AB, \n         OPS = OBP + SLG\n         )\n\nIn this example, we calculate several new statistics—batting average (BA), on-base percentage (OBP), slugging percentage (SLG), and On-base Plus Slugging (OPS)—all within the same mutate() call.\n\nThe mutate() function is a versatile and powerful tool for creating new variables and transforming existing ones. In sports analytics, this ability is invaluable when calculating advanced statistics that provide deeper insights into player and team performance. Whether you’re calculating simple metrics like batting averages or more complex statistics like on-base plus slugging, mutate() allows you to efficiently manipulate and analyze your data. In the next sections, we will explore additional dplyr functions that complement mutate(), such as select(), filter(), summarise(), and arrange()."
  },
  {
    "objectID": "01_Intro.html#using-select-to-choose-variables",
    "href": "01_Intro.html#using-select-to-choose-variables",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.2 Using select() to Choose Variables",
    "text": "1.2 Using select() to Choose Variables\nThe select() function in dplyr is a powerful tool for selecting specific columns (or variables) from a dataset. In sports analytics, datasets can contain a large number of variables, many of which may not be immediately relevant to your analysis. By using select(), you can streamline your workflow, focusing on only the columns that are essential for the task at hand.\nThe function allows you to extract specific columns based on their names, making the data more manageable and readable, especially when you’re working with large datasets like those from the NBA, MLB, or other sports leagues.\n\n1.2.1 Syntax\nThe basic syntax of select() is as follows:\ndata |&gt;\n  select(column1, column2, ...)\nHere, data is the name of the dataset, and column1, column2, etc., represent the columns you wish to select from the dataset.\n\n\n1.2.2 Why Use select()?\nIn sports analytics, it is common to work with large datasets that contain numerous variables, such as player names, performance metrics, team information, game statistics, and more. Often, you only need a few of these columns for a specific analysis. By using select(), you can focus on the relevant variables, simplifying your data and improving performance when working with large datasets.\nFor example:\n\nSelecting player performance statistics such as points, assists, and rebounds.\nNarrowing down a dataset to include only specific game information, such as game date, team, and score.\nChoosing variables that represent team-level statistics over a season, like win totals or offensive efficiency.\n\n\nExample 1.4 (Selecting Key Batting Statistics) Let’s use the Lahman dataset again, which contains a wealth of baseball statistics. Suppose we are only interested in a few key batting statistics, such as player ID (playerID), year (yearID), at-bats (AB), hits (H), and home runs (HR). We can use select() to extract these columns:\n\nlibrary(dplyr)\nlibrary(Lahman)\n\nbatting_data_selected = Batting |&gt;\n  select(playerID, yearID, AB, H, HR)\n\nhead(batting_data_selected)\n\n   playerID yearID  AB  H HR\n1 abercda01   1871   4  0  0\n2  addybo01   1871 118 32  0\n3 allisar01   1871 137 40  0\n4 allisdo01   1871 133 44  2\n5 ansonca01   1871 120 39  0\n6 armstbo01   1871  49 11  0\n\n\nIn this example, the select() function filters the dataset down to just the columns playerID, yearID, AB, H, and HR. This is especially useful when you’re conducting specific analyses on player performance metrics like at-bats (AB), hits (H), and home runs (HR).\n\n\n\n1.2.3 Selecting Columns by Range\nYou can also select columns by specifying a range using the colon (:) operator. This is helpful when dealing with consecutive columns that you wish to include in your analysis.\n\nExample 1.5 (Selecting a range of columns) Let’s say you want to select all the columns between AB and HR in the batting dataset.\n\nbatting_data_range = Batting |&gt;\n  select(AB:HR)\n\nhead(batting_data_range)\n\n   AB  R  H X2B X3B HR\n1   4  0  0   0   0  0\n2 118 30 32   6   0  0\n3 137 28 40   4   5  0\n4 133 28 44  10   2  2\n5 120 29 39  11   3  0\n6  49  9 11   2   1  0\n\n\nIn this example, the select(AB:HR) syntax selects all columns from AB to HR inclusively. This feature is handy when you want to work with a block of consecutive columns.\n\n\n\n1.2.4 Dropping Columns\nIn some cases, you might want to exclude certain columns from your dataset rather than select specific ones. You can do this using the - sign in combination with select() to drop unwanted columns.\n\nExample 1.6 (Dropping a specific column) Let’s say you want to keep all columns except for the player’s ID (playerID).\n\nbatting_data_dropped = Batting |&gt;\n  select(-playerID)\n\nhead(batting_data_dropped)\n\n  yearID stint teamID lgID  G  AB  R  H X2B X3B HR RBI SB CS BB SO IBB HBP SH\n1   1871     1    TRO   NA  1   4  0  0   0   0  0   0  0  0  0  0  NA  NA NA\n2   1871     1    RC1   NA 25 118 30 32   6   0  0  13  8  1  4  0  NA  NA NA\n3   1871     1    CL1   NA 29 137 28 40   4   5  0  19  3  1  2  5  NA  NA NA\n4   1871     1    WS3   NA 27 133 28 44  10   2  2  27  1  1  0  2  NA  NA NA\n5   1871     1    RC1   NA 25 120 29 39  11   3  0  16  6  2  2  1  NA  NA NA\n6   1871     1    FW1   NA 12  49  9 11   2   1  0   5  0  1  0  1  NA  NA NA\n  SF GIDP\n1 NA    0\n2 NA    0\n3 NA    1\n4 NA    0\n5 NA    0\n6 NA    0\n\n\nHere, select(-playerID) removes the playerID column from the dataset, returning all other columns. This is useful when you want to retain most of the dataset but exclude a few irrelevant variables.\n\n\n\n1.2.5 Using Helper Functions with select()\ndplyr also provides helper functions that allow you to select columns based on certain patterns or criteria. These include:\n\nstarts_with(): Select columns whose names start with a certain prefix.\nends_with(): Select columns whose names end with a certain suffix.\ncontains(): Select columns whose names contain a certain string.\nmatches(): Select columns that match a regular expression.\n\nThese functions are particularly useful when working with datasets where columns follow a naming convention, such as stats that begin with “player_” or end with “_rate.”\n\nExample 1.7 (Selecting Columns that Start with a Prefix) Suppose you are working with a basketball dataset and want to select all statistics related to shooting that start with field_goals. In this example, we will use the hoopR package in R. This package provide functions for fetching NBA and men’s college basketball data.\n\nlibrary(hoopR)\n\n#load the data for 2023\nbasketball_data = load_nba_player_box(seasons = 2023)\n\n\nshooting_stats = basketball_data |&gt;\n  select(starts_with(\"field_goals\"))\n\nhead(shooting_stats)\n\n# A tibble: 6 × 2\n  field_goals_made field_goals_attempted\n             &lt;int&gt;                 &lt;int&gt;\n1                1                     4\n2                5                    18\n3                9                    20\n4                3                    13\n5                5                    12\n6                2                     6\n\n\nIn this example, select(starts_with(\"field_goals\")) extracts all columns whose names begin with “field_goals,” such as field_goals_made, and field_goals_attempted.\n\nThe select() function is a highly flexible tool for extracting relevant columns from large datasets, making it easier to work with and analyze the data that matters most. Whether you’re working with baseball, basketball, or any other sport, select() can streamline your workflow, helping you focus on the specific variables that are critical to your analysis. By combining select() with helper functions, such as starts_with(), ends_with(), and others, you can perform more advanced selections based on patterns or column names, further enhancing your ability to manipulate sports data.\nIn the next section, we’ll explore how to subset your data using filter() to focus on specific cases or observations based on conditions, such as selecting players above a certain performance threshold."
  },
  {
    "objectID": "01_Intro.html#using-filter-to-subset-the-data",
    "href": "01_Intro.html#using-filter-to-subset-the-data",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.3 Using filter() to Subset the Data",
    "text": "1.3 Using filter() to Subset the Data\nThe filter() function in dplyr is used to subset rows in a dataset based on specified conditions. This function allows you to extract observations that meet certain criteria, which is crucial in sports analytics when you need to focus on specific players, teams, or events. Whether you’re interested in filtering by player performance, team rankings, or game outcomes, filter() enables you to work with just the relevant data for your analysis.\n\n1.3.1 Syntax\nThe basic syntax of filter() is as follows:\ndata |&gt; \n  filter(condition1, condition2, ...)\nHere, data is the dataset, and condition1, condition2, etc., are the conditions that the rows must meet to be included in the subset. Conditions typically involve logical comparisons, such as &gt;, &lt;, ==, !=, and %in%.\n\n\n1.3.2 Why Use filter()?\nIn sports analytics, datasets often contain a wealth of information about many players, games, or seasons. However, your analysis might focus on a specific subset of this data, such as:\n\nFiltering players with more than a certain number of points or minutes played.\nFocusing on teams with a winning percentage above a specific threshold.\nSubsetting games where a team scored over 100 points.\nIsolating data from a particular season, team, or player.\n\nBy using filter(), you can isolate the rows that are most relevant to your analysis, making it easier to conduct meaningful evaluations or comparisons.\n\nExample 1.8 (Filtering Players with More than 200 At-Bats) Let’s return to the Lahman dataset and use filter() to subset players who had more than 200 at-bats in a given season. This kind of filtering is useful when analyzing only those players who had significant playing time.\n\nlibrary(dplyr)\nlibrary(Lahman)\n\nbatting_filtered = Batting |&gt;\n  filter(AB &gt; 200)\n\nhead(batting_filtered)\n\n   playerID yearID stint teamID lgID  G  AB  R  H X2B X3B HR RBI SB CS BB SO\n1 ansonca01   1872     1    PH1   NA 46 217 60 90  10   7  0  48  6  6 16  3\n2 barnero01   1872     1    BS1   NA 45 230 81 99  28   2  1  44 12  2  9  4\n3 bechtge01   1872     1    NY2   NA 51 247 61 74  11   3  0  42  9  1  7  3\n4 cummica01   1872     1    NY2   NA 55 249 37 52   9   3  0  26  0  1  4 14\n5 cuthbne01   1872     1    PH1   NA 47 260 83 88  10   0  1  47 14  4  6 10\n6 eggleda01   1872     1    NY2   NA 56 290 94 97  20   0  0  19 18  6  8  9\n  IBB HBP SH SF GIDP\n1  NA  NA NA NA    2\n2  NA  NA NA NA    3\n3  NA  NA NA NA    2\n4  NA  NA NA NA    2\n5  NA  NA NA NA    2\n6  NA  NA NA NA    0\n\n\nIn this example, we use filter(AB &gt; 200) to keep only the rows where players had more than 200 at-bats (AB). This ensures that our analysis focuses on players with sufficient playing time, avoiding the inclusion of those who had limited opportunities.\n\n\n\n1.3.3 Filtering on Multiple Conditions\nYou can use filter() to apply multiple conditions at once, allowing for more precise subsetting. Multiple conditions can be combined with logical operators such as & (AND) and | (OR).\n\nExample 1.9 (Filtering Players with More than 200 At-Bats and More Than 20 Home Runs)  \n\nbatting_filtered_multiple = Batting |&gt;\n  filter(AB &gt; 200 & HR &gt; 20)\n\nhead(batting_filtered_multiple)\n\n   playerID yearID stint teamID lgID   G  AB   R   H X2B X3B HR RBI SB CS BB SO\n1 ansonca01   1884     1    CHN   NL 112 475 108 159  30   3 21 102 NA NA 29 13\n2 dalryab01   1884     1    CHN   NL 111 521 111 161  18   9 22  69 NA NA 14 39\n3 pfefffr01   1884     1    CHN   NL 112 467 105 135  10  10 25 101 NA NA 25 47\n4 willine01   1884     1    CHN   NL 107 417  84 116  18   8 27  84 NA NA 42 56\n5 freembu01   1899     1    WAS   NL 155 588 107 187  19  25 25 122 21 NA 23 25\n6 schulfr01   1911     1    CHN   NL 154 577 105 173  30  21 21 107 23 NA 76 71\n  IBB HBP SH SF GIDP\n1  NA  NA NA NA   NA\n2  NA  NA NA NA   NA\n3  NA  NA NA NA   NA\n4  NA  NA NA NA   NA\n5  NA  18  5 NA   NA\n6  NA   3 31 NA   NA\n\n\nHere, we use filter(AB &gt; 200 & HR &gt; 20) to select players who had more than 200 at-bats and also hit more than 20 home runs in a season. This type of filtering is useful for identifying high-performing players who both played regularly and demonstrated power-hitting ability.\n\n\n\n1.3.4 Filtering with Logical Operators\nYou can apply more complex logical conditions with filter(). For example, if you wanted to find players who either had more than 200 at-bats or hit more than 20 home runs (but not necessarily both), you could use the OR operator |.\n\nExample 1.10 (Using OR condition)  \n\nbatting_filtered_or = Batting |&gt;\n  filter(AB &gt; 200 | HR &gt; 20)\n\nhead(batting_filtered_or)\n\n   playerID yearID stint teamID lgID  G  AB  R  H X2B X3B HR RBI SB CS BB SO\n1 ansonca01   1872     1    PH1   NA 46 217 60 90  10   7  0  48  6  6 16  3\n2 barnero01   1872     1    BS1   NA 45 230 81 99  28   2  1  44 12  2  9  4\n3 bechtge01   1872     1    NY2   NA 51 247 61 74  11   3  0  42  9  1  7  3\n4 cummica01   1872     1    NY2   NA 55 249 37 52   9   3  0  26  0  1  4 14\n5 cuthbne01   1872     1    PH1   NA 47 260 83 88  10   0  1  47 14  4  6 10\n6 eggleda01   1872     1    NY2   NA 56 290 94 97  20   0  0  19 18  6  8  9\n  IBB HBP SH SF GIDP\n1  NA  NA NA NA    2\n2  NA  NA NA NA    3\n3  NA  NA NA NA    2\n4  NA  NA NA NA    2\n5  NA  NA NA NA    2\n6  NA  NA NA NA    0\n\n\nIn this example, players are included in the subset if they meet either of the conditions: more than 200 at-bats or more than 20 home runs.\n\n\n\n1.3.5 Using %in% to Filter by a Set of Values\nThe %in% operator can be used within filter() to check whether a column’s values belong to a specific set. This is particularly useful when you want to filter by specific categories, such as player IDs, teams, or years.\n\nExample 1.11 (Filtering Data for Specific Years) Let’s say you want to analyze data from only the 2010 and 2015 seasons.\n\nbatting_filtered_years = Batting |&gt;\n  filter(yearID %in% c(2010, 2015))\n\nhead(batting_filtered_years)\n\n   playerID yearID stint teamID lgID   G  AB  R   H X2B X3B HR RBI SB CS BB  SO\n1 aardsda01   2010     1    SEA   AL  53   0  0   0   0   0  0   0  0  0  0   0\n2  abadfe01   2010     1    HOU   NL  22   1  0   0   0   0  0   0  0  0  0   1\n3 abreubo01   2010     1    LAA   AL 154 573 88 146  41   1 20  78 24 10 87 132\n4 abreuto01   2010     1    ARI   NL  81 193 16  45  11   1  1  13  2  1  4  47\n5 accarje01   2010     1    TOR   AL   5   0  0   0   0   0  0   0  0  0  0   0\n6 aceveal01   2010     1    NYA   AL  10   0  0   0   0   0  0   0  0  0  0   0\n  IBB HBP SH SF GIDP\n1   0   0  0  0    0\n2   0   0  0  0    0\n3   3   2  0  5   13\n4   0   0  0  4    8\n5   0   0  0  0    0\n6   0   0  0  0    0\n\n\nIn this example, we use filter(yearID %in% c(2010, 2015)) to retain only the rows where the yearID column matches 2010 or 2015. This approach is helpful when working with data from specific seasons or games.\n\n\n\n1.3.6 Filtering Missing Data\nIn many datasets, missing values (represented as NA in R) can cause problems if not handled properly. You can use filter() to exclude rows with missing values or to isolate rows where certain values are missing.\n\nExample 1.12 (Filtering Out Missing Data) Let’s filter out rows where the number of at-bats (AB) is missing.\n\n# Removing rows with missing values for at-bats\nbatting_no_na = Batting |&gt;\n  filter(!is.na(AB))\n\nhead(batting_no_na)\n\n   playerID yearID stint teamID lgID  G  AB  R  H X2B X3B HR RBI SB CS BB SO\n1 abercda01   1871     1    TRO   NA  1   4  0  0   0   0  0   0  0  0  0  0\n2  addybo01   1871     1    RC1   NA 25 118 30 32   6   0  0  13  8  1  4  0\n3 allisar01   1871     1    CL1   NA 29 137 28 40   4   5  0  19  3  1  2  5\n4 allisdo01   1871     1    WS3   NA 27 133 28 44  10   2  2  27  1  1  0  2\n5 ansonca01   1871     1    RC1   NA 25 120 29 39  11   3  0  16  6  2  2  1\n6 armstbo01   1871     1    FW1   NA 12  49  9 11   2   1  0   5  0  1  0  1\n  IBB HBP SH SF GIDP\n1  NA  NA NA NA    0\n2  NA  NA NA NA    0\n3  NA  NA NA NA    1\n4  NA  NA NA NA    0\n5  NA  NA NA NA    0\n6  NA  NA NA NA    0\n\n\nHere, we use filter(!is.na(AB)) to remove rows where the value for at-bats (AB) is missing (NA). This ensures that we are working only with complete data.\n\nThe filter() function is an indispensable tool for narrowing down large datasets based on specific criteria. Whether you’re filtering by player performance, season, or game outcomes, filter() allows you to extract just the rows that are most relevant to your analysis. In sports analytics, this enables you to focus on specific players, teams, or metrics that drive meaningful insights.\nIn the next section, we will explore how to use the summarise() function to aggregate data, such as calculating team-level statistics or summarizing player performance over a season or career."
  },
  {
    "objectID": "01_Intro.html#using-summarise-to-aggregate-data",
    "href": "01_Intro.html#using-summarise-to-aggregate-data",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.4 Using summarise() to Aggregate Data",
    "text": "1.4 Using summarise() to Aggregate Data\nThe summarise() function in dplyr is used to create summary statistics from your dataset by collapsing multiple rows into a single value. This function is essential in sports analytics, where you often need to aggregate data to calculate overall metrics, such as total points, average performance statistics, or team-level summaries. With summarise(), you can compute a wide variety of statistics such as sums, averages, minimums, and maximums, allowing for powerful aggregation of data.\n\n1.4.1 Syntax\nThe basic syntax of summarise() is as follows:\ndata |&gt; \n  summarise(new_summary = aggregation_function(column))\nWhere:\n\ndata is the dataset.\nnew_summary is the name of the new summary statistic.\naggregation_function(column) is the function applied to the column you want to summarize (e.g., mean(), sum(), min(), max()).\n\n\n\n1.4.2 Why Use summarise()?\nIn sports analytics, it is often necessary to calculate overall performance metrics, such as:\n\nSumming a player’s total points over multiple seasons.\nCalculating a team’s average points per game.\nAggregating player data to find league-wide averages or totals.\nComputing summary statistics like the highest or lowest scoring games in a season.\n\nUsing summarise(), you can efficiently compute these summary statistics and gain high-level insights from raw data.\n\n\n1.4.3 Grouping Data Before Summarizing\nWhen using summarise(), it’s common to group data by one or more variables before applying the summary function. This is achieved with the group_by() function, which allows you to summarize data across different categories, such as by player, team, or season.\nFor example:\n\nSummarizing total points per player across multiple games.\nCalculating the average performance metrics per team in a season.\nAggregating statistics by season to track trends over time.\n\n\nExample 1.13 (Summarizing Total Home Runs per Year) Let’s use the Lahman dataset to calculate the total number of home runs hit by all players for each year. First, we will group the data by year and then use summarise() to compute the total home runs.\n\nlibrary(dplyr)\nlibrary(Lahman)\n\n# Summarizing total home runs per year\nhome_runs_per_year &lt;- Batting |&gt;\n  group_by(yearID) |&gt;\n  summarise(total_HR = sum(HR, na.rm = TRUE))\n\nhead(home_runs_per_year)\n\n# A tibble: 6 × 2\n  yearID total_HR\n   &lt;int&gt;    &lt;int&gt;\n1   1871       47\n2   1872       37\n3   1873       47\n4   1874       40\n5   1875       40\n6   1876       40\n\n\nIn this example, we first use group_by(yearID) to group the data by year, and then summarise() is used to compute the total number of home runs (HR) hit in each year. The na.rm = TRUE argument ensures that missing values are ignored during the summation. This type of summary can help analyze trends in home run performance over time.\n\n\nExample 1.14 (Calculating Average Batting Average per Year) You can also calculate averages using summarise(). Let’s calculate the average batting average (BA) for each year by grouping the data by yearID and then using the mean() function within summarise().\n\n# Calculating average batting average per year\nbatting_average_per_year &lt;- Batting |&gt;\n  group_by(yearID) |&gt;\n  summarise(avg_BA = mean(H / AB, na.rm = TRUE))\n\nhead(batting_average_per_year)\n\n# A tibble: 6 × 2\n  yearID avg_BA\n   &lt;int&gt;  &lt;dbl&gt;\n1   1871  0.254\n2   1872  0.246\n3   1873  0.252\n4   1874  0.240\n5   1875  0.218\n6   1876  0.211\n\n\nIn this example, we compute the average batting average (avg_BA) for each year. The mean() function calculates the average of hits divided by at-bats, and na.rm = TRUE ensures that missing data is handled appropriately.\n\n\nMultiple Summaries with summarise()\nYou can compute multiple summary statistics in a single summarise() call by simply listing additional summary expressions separated by commas.\n\nExample 1.15 (Summarizing Both Total and Average Home Runs per Year)  \n\n# Summarizing total and average home runs per year\nhome_run_stats &lt;- Batting |&gt;\n  group_by(yearID) |&gt;\n  summarise(total_HR = sum(HR, na.rm = TRUE),\n            avg_HR = mean(HR, na.rm = TRUE))\n\nhead(home_run_stats)\n\n# A tibble: 6 × 3\n  yearID total_HR avg_HR\n   &lt;int&gt;    &lt;int&gt;  &lt;dbl&gt;\n1   1871       47  0.409\n2   1872       37  0.236\n3   1873       47  0.376\n4   1874       40  0.325\n5   1875       40  0.184\n6   1876       40  0.323\n\n\nIn this example, we calculate both the total home runs (total_HR) and the average home runs per player (avg_HR) for each year. This provides both a high-level view (total) and a per-player perspective (average) of home run performance.\n\n\n\n\n1.4.4 Adding Summary Statistics to the Original Data\nIn some cases, you may want to add summary statistics back to your original dataset. This can be achieved by combining mutate() with summarise() to append calculated statistics to each row.\n\nExample 1.16 (Adding Average Points per Player to Each Team)  \n\nlibrary(hoopR)\n\n#load the data for 2023\nbasketball_data = load_nba_player_box(seasons = 2023)\n\n\nnba_stats = basketball_data |&gt;\n  group_by(team_name) |&gt; \n  summarize(avg_pts_team = mean(points, na.rm = TRUE)) |&gt; \n  right_join(basketball_data, by = \"team_name\")\n\nhead(nba_stats)\n\n# A tibble: 6 × 58\n  team_name avg_pts_team   game_id season season_type game_date \n  &lt;chr&gt;            &lt;dbl&gt;     &lt;int&gt;  &lt;int&gt;       &lt;int&gt; &lt;date&gt;    \n1 76ers             10.5 401545117   2023           3 2023-05-14\n2 76ers             10.5 401545117   2023           3 2023-05-14\n3 76ers             10.5 401545117   2023           3 2023-05-14\n4 76ers             10.5 401545117   2023           3 2023-05-14\n5 76ers             10.5 401545117   2023           3 2023-05-14\n6 76ers             10.5 401545117   2023           3 2023-05-14\n# ℹ 52 more variables: game_date_time &lt;dttm&gt;, athlete_id &lt;int&gt;,\n#   athlete_display_name &lt;chr&gt;, team_id &lt;int&gt;, team_location &lt;chr&gt;,\n#   team_short_display_name &lt;chr&gt;, minutes &lt;dbl&gt;, field_goals_made &lt;int&gt;,\n#   field_goals_attempted &lt;int&gt;, three_point_field_goals_made &lt;int&gt;,\n#   three_point_field_goals_attempted &lt;int&gt;, free_throws_made &lt;int&gt;,\n#   free_throws_attempted &lt;int&gt;, offensive_rebounds &lt;int&gt;,\n#   defensive_rebounds &lt;int&gt;, rebounds &lt;int&gt;, assists &lt;int&gt;, steals &lt;int&gt;, …\n\n\nIn this example, we first calculate the average points per team (avg_pts_team) and then use right_join() to merge this summary statistic back into the original dataset, so that each player’s row now contains their team’s average points.\n\nThe summarise() function is a critical tool for aggregating and summarizing data in sports analytics. Whether you’re calculating total points, average performance metrics, or team-level statistics, summarise() allows you to collapse large datasets into meaningful summary statistics. By combining summarise() with group_by(), you can gain insights into trends across seasons, teams, or players, providing a comprehensive view of the data.\nIn the next section, we’ll explore the arrange() function, which is used to order and rank your data, making it easier to identify top performers and trends."
  },
  {
    "objectID": "01_Intro.html#using-arrange-to-order-rows",
    "href": "01_Intro.html#using-arrange-to-order-rows",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.5 Using arrange() to Order Rows",
    "text": "1.5 Using arrange() to Order Rows\nThe arrange() function in dplyr is used to reorder the rows of a dataset based on the values of one or more variables. This function is particularly useful in sports analytics when you want to rank players or teams according to performance metrics, such as points scored, assists made, or wins achieved. By using arrange(), you can quickly identify top performers, sort data chronologically, or rank teams based on standings.\n\n1.5.1 Syntax\nThe basic syntax of arrange() is as follows:\ndata |&gt; \n  arrange(column1, column2, ...)\nWhere:\n\ndata is the dataset.\ncolumn1, column2, etc., are the columns by which the data should be ordered.\n\nBy default, arrange() sorts the rows in ascending order. To sort in descending order, you can wrap the column name in desc().\n\n\n1.5.2 Why Use arrange()?\nIn sports analytics, ranking and sorting data is a common task. Whether you’re determining the highest scorers, ordering teams by win percentage, or ranking players by efficiency, arrange() allows you to easily reorder your data to facilitate comparisons and insights.\nFor example, you may want to:\n\nRank basketball players by points scored per game.\nSort baseball teams by total wins.\nRank athletes by efficiency ratings, from highest to lowest.\n\n\nExample 1.17 (Arranging by Batting Average) Let’s use the Lahman dataset again and sort the players by their batting average (BA). First, we need to calculate the batting average using mutate() and then sort the dataset in descending order to identify the top performers.\n\nlibrary(dplyr)\nlibrary(Lahman)\n\nbatting_data &lt;- Batting |&gt;\n  mutate(BA = H / AB) |&gt;\n  arrange(desc(BA))\n\nhead(batting_data)\n\n   playerID yearID stint teamID lgID G AB R H X2B X3B HR RBI SB CS BB SO IBB\n1  snowch01   1874     1    BR2   NA 1  1 0 1   0   0  0   0  0  0  0  0  NA\n2 baldwki01   1884     2    CHU   UA 1  1 0 1   0   0  0  NA NA NA  0 NA  NA\n3 mccafsp01   1889     1    CL6   AA 2  1 1 1   0   0  0   0  0 NA  1  0  NA\n4 gumbebi01   1893     1    LS3   NL 1  1 0 1   1   0  0   2  0 NA  0  0  NA\n5 oconnfr01   1893     1    PHI   NL 3  2 1 2   0   0  1   3  0 NA  0  0  NA\n6 brownpe01   1894     2    BRO   NL 1  2 1 2   0   0  0   2  0 NA  1  0  NA\n  HBP SH SF GIDP BA\n1  NA NA NA    0  1\n2  NA NA NA   NA  1\n3   0 NA NA   NA  1\n4   0 NA NA   NA  1\n5   0 NA NA   NA  1\n6   0  0 NA   NA  1\n\n\nIn this example, we first calculate the batting average (BA) using mutate() and then use arrange(desc(BA)) to sort the data in descending order of batting average. This allows us to see the players with the highest batting averages at the top of the dataset.\n\n\n\n1.5.3 Arranging by Multiple Variables\nYou can also sort data by multiple columns. For example, if two players have the same batting average, you might want to break the tie by looking at their home run totals.\n\nExample 1.18 (Arranging by Batting Average and Home Runs)  \n\nbatting_data_sorted &lt;- Batting |&gt;\n  mutate(BA = H / AB) |&gt;\n  arrange(desc(BA), desc(HR))\n\nhead(batting_data_sorted)\n\n   playerID yearID stint teamID lgID  G AB R H X2B X3B HR RBI SB CS BB SO IBB\n1 oconnfr01   1893     1    PHI   NL  3  2 1 2   0   0  1   3  0 NA  0  0  NA\n2 lefebbi01   1938     1    BOS   AL  1  1 1 1   0   0  1   1  0  0  0  0  NA\n3 sleatlo01   1958     1    DET   AL  4  1 1 1   0   0  1   1  0  0  0  0   0\n4 narumbu01   1963     1    BAL   AL  7  1 1 1   0   0  1   2  0  0  0  0   0\n5 quirkja01   1984     2    CLE   AL  1  1 1 1   0   0  1   1  0  0  0  0   0\n6 perrypa02   1988     2    CHN   NL 35  1 1 1   0   0  1   2  0  0  0  0   0\n  HBP SH SF GIDP BA\n1   0 NA NA   NA  1\n2   0  0 NA   NA  1\n3   0  0  0    0  1\n4   0  0  0    0  1\n5   0  0  0    0  1\n6   0  0  0    0  1\n\n\nHere, we first sort by batting average (BA) in descending order, and in the case of ties, we further arrange the rows by home runs (HR) in descending order. This type of multi-variable sorting is useful for resolving ties or ranking data based on multiple criteria.\n\n\n\n1.5.4 Sorting Chronologically\nIn many sports datasets, you might want to sort data chronologically to observe trends over time. This can be done by arranging data by a date or year variable.\n\nExample 1.19 (Sorting by Year) Let’s sort the ‘Lahman’ dataset by the yearID variable to view the data in chronological order.\n\nbatting_data_by_year &lt;- Batting |&gt;\n  arrange(desc(yearID))\n\nhead(batting_data_by_year)\n\n   playerID yearID stint teamID lgID  G  AB  R  H X2B X3B HR RBI SB CS BB SO\n1 abbotco01   2022     1    WAS   NL 16   0  0  0   0   0  0   0  0  0  0  0\n2 abramcj01   2022     1    SDN   NL 46 125 16 29   5   0  2  11  1  2  4 27\n3 abramcj01   2022     2    WAS   NL 44 159 17 41   7   2  0  10  6  2  1 23\n4 abreual01   2022     1    TEX   AL  7   0  0  0   0   0  0   0  0  0  0  0\n5 abreual01   2022     2    KCA   AL  4   0  0  0   0   0  0   0  0  0  0  0\n6 abreual01   2022     3    NYA   AL 22   0  0  0   0   0  0   0  0  0  0  0\n  IBB HBP SH SF GIDP\n1   0   0  0  0    0\n2   0   6  2  2    4\n3   0   3  0  0    1\n4   0   0  0  0    0\n5   0   0  0  0    0\n6   0   0  0  0    0\n\n\nThis example sorts the data in ascending order by yearID, allowing us to see the dataset arranged chronologically by season. Sorting by year or date is especially useful when analyzing time trends in performance or observing how a player’s career evolves over time.\n\nThe arrange() function is a valuable tool in sports analytics for ordering and ranking data. Whether you’re sorting players by performance metrics, ranking teams based on wins, or organizing data chronologically, arrange() allows you to structure your data in a way that facilitates meaningful analysis. You can arrange data by one or more columns, and by using desc(), you can sort in descending order to prioritize top performers."
  },
  {
    "objectID": "01_Intro.html#test-your-comprehension",
    "href": "01_Intro.html#test-your-comprehension",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.6 Test Your Comprehension",
    "text": "1.6 Test Your Comprehension\n\nWhat is the primary function of the mutate() function in dplyr?\n\n To summarize data into a single value To select specific columns To filter rows based on a condition To add or transform variables\n\nWhich function in dplyr is used to select specific columns from a dataset?\n\n select() arrange() filter() mutate()\n\nIn the context of the mutate() function, what would happen if you attempt to divide a value by zero without handling it?\n\n The value would be automatically set to zero. It would result in an error. The value would be set to NA. It would remove the row.\n\nWhich of the following functions is used to reorder rows in a dataset?\n\n filter() summarise() arrange() mutate()\n\nTo extract rows of data that meet specific conditions, such as “players with more than 200 at-bats”, which function would you use?\n\n mutate() filter() arrange() summarise()\n\nTrue or False: The select() function allows you to drop specific columns by prefixing their names with a minus sign (-). TRUEFALSE\nTrue or False: In the filter() function, using & combines conditions in such a way that both conditions must be true for a row to be included in the subset. TRUEFALSE\nTrue or False: The arrange() function in dplyr can only sort data in ascending order. TRUEFALSE"
  }
]