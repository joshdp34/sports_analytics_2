[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STA 3311 Sports Analytics II",
    "section": "",
    "text": "Introduction\nThese are the lecture notes for STA 3311 - Sports Analytics II.\nPrerequisites: STA 3310 - Sports Analytics I\n\nCourse Description:\nDelves deeper into sports analytics, emphasizing sophisticated statistical models and data manipulation techniques to refine predictions and strategies in sports settings."
  },
  {
    "objectID": "01_Intro.html#using-mutate-to-add-or-transform-variables",
    "href": "01_Intro.html#using-mutate-to-add-or-transform-variables",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.1 Using mutate() to Add or Transform Variables",
    "text": "1.1 Using mutate() to Add or Transform Variables\nThe mutate() function in dplyr is an essential tool for creating new variables or modifying existing ones in a dataset. In the context of sports analytics, this function is particularly useful when you want to compute new metrics or adjust raw data into more meaningful forms. For example, a player’s raw performance statistics, such as hits or points scored, can be transformed into ratios or averages, providing more insightful performance measures such as batting averages or efficiency ratings.\n\n1.1.1 Syntax\nThe basic syntax of mutate() is as follows:\nmutate(data, new_variable = expression)\nHere, data is the name of the dataset you are working with, new_variable is the name of the variable you are adding or modifying, and expression is the formula used to calculate the value of the new variable.\nWe can also use the pipe operator as follows:\ndata |&gt; \nmutate(new_variable = expression)\n\n\n1.1.2 Why Use mutate()?\nIn sports analytics, it is often necessary to create variables that represent metrics or statistics derived from existing data. For example:\n\nCreating a new variable that represents a player’s scoring efficiency.\nCalculating a team’s win rate by dividing the number of wins by the total number of games played.\nComputing advanced metrics such as player efficiency rating (PER) in basketball or on-base plus slugging (OPS) in baseball.\n\nBy transforming raw data into meaningful statistics, you can uncover new insights that are not immediately apparent in the original dataset.\n\nExample 1.1 (Calculating Batting Average) Let’s begin with a basic example using data from the Lahman package, which contains Major League Baseball (MLB) statistics. We will calculate each player’s batting average (BA), a widely used performance metric that represents the ratio of a player’s hits (H) to at-bats (AB).\n\nlibrary(tidyverse)\nlibrary(Lahman)\n\n# Example: Adding Batting Average (BA) to Batting data\nbatting_data = Batting |&gt;\n  mutate(BA = H / AB)\n\nhead(batting_data)\n\n   playerID yearID stint teamID lgID  G AB R H X2B X3B HR RBI SB CS BB SO IBB\n1 aardsda01   2004     1    SFN   NL 11  0 0 0   0   0  0   0  0  0  0  0   0\n2 aardsda01   2006     1    CHN   NL 45  2 0 0   0   0  0   0  0  0  0  0   0\n3 aardsda01   2007     1    CHA   AL 25  0 0 0   0   0  0   0  0  0  0  0   0\n4 aardsda01   2008     1    BOS   AL 47  1 0 0   0   0  0   0  0  0  0  1   0\n5 aardsda01   2009     1    SEA   AL 73  0 0 0   0   0  0   0  0  0  0  0   0\n6 aardsda01   2010     1    SEA   AL 53  0 0 0   0   0  0   0  0  0  0  0   0\n  HBP SH SF GIDP  BA\n1   0  0  0    0 NaN\n2   0  1  0    0   0\n3   0  0  0    0 NaN\n4   0  0  0    0   0\n5   0  0  0    0 NaN\n6   0  0  0    0 NaN\n\n\nIn this example, we use mutate() to create a new variable BA, which stores the batting average for each player. This new column is derived from dividing the number of hits (H) by the number of at-bats (AB).\n\n\n\n1.1.3 Handling Missing Values with mutate()\nIn some cases, you may encounter missing or undefined values in your dataset. When using mutate() to create new variables, it’s important to handle these missing values to avoid errors or incorrect calculations. In R, you can use the na.rm = TRUE argument in relevant functions (like sum() or mean()) to remove missing values before performing calculations.\n\nExample 1.2 (Handling division by zero) Let’s modify the batting average calculation to handle cases where the number of at-bats (AB) is zero, which would otherwise lead to a division by zero error.\n\nbatting_data = Batting |&gt;\n  mutate(BA = ifelse(AB == 0, NA, H / AB))\n\nhead(batting_data)\n\n   playerID yearID stint teamID lgID  G AB R H X2B X3B HR RBI SB CS BB SO IBB\n1 aardsda01   2004     1    SFN   NL 11  0 0 0   0   0  0   0  0  0  0  0   0\n2 aardsda01   2006     1    CHN   NL 45  2 0 0   0   0  0   0  0  0  0  0   0\n3 aardsda01   2007     1    CHA   AL 25  0 0 0   0   0  0   0  0  0  0  0   0\n4 aardsda01   2008     1    BOS   AL 47  1 0 0   0   0  0   0  0  0  0  1   0\n5 aardsda01   2009     1    SEA   AL 73  0 0 0   0   0  0   0  0  0  0  0   0\n6 aardsda01   2010     1    SEA   AL 53  0 0 0   0   0  0   0  0  0  0  0   0\n  HBP SH SF GIDP BA\n1   0  0  0    0 NA\n2   0  1  0    0  0\n3   0  0  0    0 NA\n4   0  0  0    0  0\n5   0  0  0    0 NA\n6   0  0  0    0 NA\n\n\nIn this case, we use ifelse() to check if a player has zero at-bats (AB == 0). If this condition is met, we assign a missing value (NA) to the batting average, otherwise, the batting average is calculated as usual.\n\n\n\n1.1.4 Multiple Transformations with mutate()\nThe mutate() function can be used to perform multiple transformations in a single call. This is useful when you need to create several new variables based on existing data. You can also overwrite existing variables if needed.\n\nExample 1.3 (Performing multiple transformations with mutate())  \n\nbatting_data = Batting |&gt;\n  mutate(BA = ifelse(AB == 0, NA, H / AB),\n         OBP = (H + BB + HBP) / (AB + BB + SF + HBP),\n         SLG = (H - X2B - X3B - HR + 2*X2B + 3*X3B + 4*HR) / AB, \n         OPS = OBP + SLG\n         )\n\nIn this example, we calculate several new statistics—batting average (BA), on-base percentage (OBP), slugging percentage (SLG), and On-base Plus Slugging (OPS)—all within the same mutate() call.\n\nThe mutate() function is a versatile and powerful tool for creating new variables and transforming existing ones. In sports analytics, this ability is invaluable when calculating advanced statistics that provide deeper insights into player and team performance. Whether you’re calculating simple metrics like batting averages or more complex statistics like on-base plus slugging, mutate() allows you to efficiently manipulate and analyze your data. In the next sections, we will explore additional dplyr functions that complement mutate(), such as select(), filter(), summarise(), and arrange()."
  },
  {
    "objectID": "01_Intro.html#using-select-to-choose-variables",
    "href": "01_Intro.html#using-select-to-choose-variables",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.2 Using select() to Choose Variables",
    "text": "1.2 Using select() to Choose Variables\nThe select() function in dplyr is a powerful tool for selecting specific columns (or variables) from a dataset. In sports analytics, datasets can contain a large number of variables, many of which may not be immediately relevant to your analysis. By using select(), you can streamline your workflow, focusing on only the columns that are essential for the task at hand.\nThe function allows you to extract specific columns based on their names, making the data more manageable and readable, especially when you’re working with large datasets like those from the NBA, MLB, or other sports leagues.\n\n1.2.1 Syntax\nThe basic syntax of select() is as follows:\ndata |&gt;\n  select(column1, column2, ...)\nHere, data is the name of the dataset, and column1, column2, etc., represent the columns you wish to select from the dataset.\n\n\n1.2.2 Why Use select()?\nIn sports analytics, it is common to work with large datasets that contain numerous variables, such as player names, performance metrics, team information, game statistics, and more. Often, you only need a few of these columns for a specific analysis. By using select(), you can focus on the relevant variables, simplifying your data and improving performance when working with large datasets.\nFor example:\n\nSelecting player performance statistics such as points, assists, and rebounds.\nNarrowing down a dataset to include only specific game information, such as game date, team, and score.\nChoosing variables that represent team-level statistics over a season, like win totals or offensive efficiency.\n\n\nExample 1.4 (Selecting Key Batting Statistics) Let’s use the Lahman dataset again, which contains a wealth of baseball statistics. Suppose we are only interested in a few key batting statistics, such as player ID (playerID), year (yearID), at-bats (AB), hits (H), and home runs (HR). We can use select() to extract these columns:\n\nlibrary(dplyr)\nlibrary(Lahman)\n\nbatting_data_selected = Batting |&gt;\n  select(playerID, yearID, AB, H, HR)\n\nhead(batting_data_selected)\n\n   playerID yearID AB H HR\n1 aardsda01   2004  0 0  0\n2 aardsda01   2006  2 0  0\n3 aardsda01   2007  0 0  0\n4 aardsda01   2008  1 0  0\n5 aardsda01   2009  0 0  0\n6 aardsda01   2010  0 0  0\n\n\nIn this example, the select() function filters the dataset down to just the columns playerID, yearID, AB, H, and HR. This is especially useful when you’re conducting specific analyses on player performance metrics like at-bats (AB), hits (H), and home runs (HR).\n\n\n\n1.2.3 Selecting Columns by Range\nYou can also select columns by specifying a range using the colon (:) operator. This is helpful when dealing with consecutive columns that you wish to include in your analysis.\n\nExample 1.5 (Selecting a range of columns) Let’s say you want to select all the columns between AB and HR in the batting dataset.\n\nbatting_data_range = Batting |&gt;\n  select(AB:HR)\n\nhead(batting_data_range)\n\n  AB R H X2B X3B HR\n1  0 0 0   0   0  0\n2  2 0 0   0   0  0\n3  0 0 0   0   0  0\n4  1 0 0   0   0  0\n5  0 0 0   0   0  0\n6  0 0 0   0   0  0\n\n\nIn this example, the select(AB:HR) syntax selects all columns from AB to HR inclusively. This feature is handy when you want to work with a block of consecutive columns.\n\n\n\n1.2.4 Dropping Columns\nIn some cases, you might want to exclude certain columns from your dataset rather than select specific ones. You can do this using the - sign in combination with select() to drop unwanted columns.\n\nExample 1.6 (Dropping a specific column) Let’s say you want to keep all columns except for the player’s ID (playerID).\n\nbatting_data_dropped = Batting |&gt;\n  select(-playerID)\n\nhead(batting_data_dropped)\n\n  yearID stint teamID lgID  G AB R H X2B X3B HR RBI SB CS BB SO IBB HBP SH SF\n1   2004     1    SFN   NL 11  0 0 0   0   0  0   0  0  0  0  0   0   0  0  0\n2   2006     1    CHN   NL 45  2 0 0   0   0  0   0  0  0  0  0   0   0  1  0\n3   2007     1    CHA   AL 25  0 0 0   0   0  0   0  0  0  0  0   0   0  0  0\n4   2008     1    BOS   AL 47  1 0 0   0   0  0   0  0  0  0  1   0   0  0  0\n5   2009     1    SEA   AL 73  0 0 0   0   0  0   0  0  0  0  0   0   0  0  0\n6   2010     1    SEA   AL 53  0 0 0   0   0  0   0  0  0  0  0   0   0  0  0\n  GIDP\n1    0\n2    0\n3    0\n4    0\n5    0\n6    0\n\n\nHere, select(-playerID) removes the playerID column from the dataset, returning all other columns. This is useful when you want to retain most of the dataset but exclude a few irrelevant variables.\n\n\n\n1.2.5 Using Helper Functions with select()\ndplyr also provides helper functions that allow you to select columns based on certain patterns or criteria. These include:\n\nstarts_with(): Select columns whose names start with a certain prefix.\nends_with(): Select columns whose names end with a certain suffix.\ncontains(): Select columns whose names contain a certain string.\nmatches(): Select columns that match a regular expression.\n\nThese functions are particularly useful when working with datasets where columns follow a naming convention, such as stats that begin with “player_” or end with “_rate.”\n\nExample 1.7 (Selecting Columns that Start with a Prefix) Suppose you are working with a basketball dataset and want to select all statistics related to shooting that start with field_goals. In this example, we will use the hoopR package in R. This package provide functions for fetching NBA and men’s college basketball data.\n\nlibrary(hoopR)\n\n#load the data for 2023\nbasketball_data = load_nba_player_box(seasons = 2023)\n\n\nshooting_stats = basketball_data |&gt;\n  select(starts_with(\"field_goals\"))\n\nhead(shooting_stats)\n\n# A tibble: 6 × 2\n  field_goals_made field_goals_attempted\n             &lt;int&gt;                 &lt;int&gt;\n1                1                     4\n2                5                    18\n3                9                    20\n4                3                    13\n5                5                    12\n6                2                     6\n\n\nIn this example, select(starts_with(\"field_goals\")) extracts all columns whose names begin with “field_goals,” such as field_goals_made, and field_goals_attempted.\n\nThe select() function is a highly flexible tool for extracting relevant columns from large datasets, making it easier to work with and analyze the data that matters most. Whether you’re working with baseball, basketball, or any other sport, select() can streamline your workflow, helping you focus on the specific variables that are critical to your analysis. By combining select() with helper functions, such as starts_with(), ends_with(), and others, you can perform more advanced selections based on patterns or column names, further enhancing your ability to manipulate sports data.\nIn the next section, we’ll explore how to subset your data using filter() to focus on specific cases or observations based on conditions, such as selecting players above a certain performance threshold."
  },
  {
    "objectID": "01_Intro.html#using-filter-to-subset-the-data",
    "href": "01_Intro.html#using-filter-to-subset-the-data",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.3 Using filter() to Subset the Data",
    "text": "1.3 Using filter() to Subset the Data\nThe filter() function in dplyr is used to subset rows in a dataset based on specified conditions. This function allows you to extract observations that meet certain criteria, which is crucial in sports analytics when you need to focus on specific players, teams, or events. Whether you’re interested in filtering by player performance, team rankings, or game outcomes, filter() enables you to work with just the relevant data for your analysis.\n\n1.3.1 Syntax\nThe basic syntax of filter() is as follows:\ndata |&gt; \n  filter(condition1, condition2, ...)\nHere, data is the dataset, and condition1, condition2, etc., are the conditions that the rows must meet to be included in the subset. Conditions typically involve logical comparisons, such as &gt;, &lt;, ==, !=, and %in%.\n\n\n1.3.2 Why Use filter()?\nIn sports analytics, datasets often contain a wealth of information about many players, games, or seasons. However, your analysis might focus on a specific subset of this data, such as:\n\nFiltering players with more than a certain number of points or minutes played.\nFocusing on teams with a winning percentage above a specific threshold.\nSubsetting games where a team scored over 100 points.\nIsolating data from a particular season, team, or player.\n\nBy using filter(), you can isolate the rows that are most relevant to your analysis, making it easier to conduct meaningful evaluations or comparisons.\n\nExample 1.8 (Filtering Players with More than 200 At-Bats) Let’s return to the Lahman dataset and use filter() to subset players who had more than 200 at-bats in a given season. This kind of filtering is useful when analyzing only those players who had significant playing time.\n\nlibrary(dplyr)\nlibrary(Lahman)\n\nbatting_filtered = Batting |&gt;\n  filter(AB &gt; 200)\n\nhead(batting_filtered)\n\n   playerID yearID stint teamID lgID   G  AB   R   H X2B X3B HR RBI SB CS BB SO\n1 aaronha01   1954     1    ML1   NL 122 468  58 131  27   6 13  69  2  2 28 39\n2 aaronha01   1955     1    ML1   NL 153 602 105 189  37   9 27 106  3  1 49 61\n3 aaronha01   1956     1    ML1   NL 153 609 106 200  34  14 26  92  2  4 37 54\n4 aaronha01   1957     1    ML1   NL 151 615 118 198  27   6 44 132  1  1 57 58\n5 aaronha01   1958     1    ML1   NL 153 601 109 196  34   4 30  95  4  1 59 49\n6 aaronha01   1959     1    ML1   NL 154 629 116 223  46   7 39 123  8  0 51 54\n  IBB HBP SH SF GIDP\n1  NA   3  6  4   13\n2   5   3  7  4   20\n3   6   2  5  7   21\n4  15   0  0  3   13\n5  16   1  0  3   21\n6  17   4  0  9   19\n\n\nIn this example, we use filter(AB &gt; 200) to keep only the rows where players had more than 200 at-bats (AB). This ensures that our analysis focuses on players with sufficient playing time, avoiding the inclusion of those who had limited opportunities.\n\n\n\n1.3.3 Filtering on Multiple Conditions\nYou can use filter() to apply multiple conditions at once, allowing for more precise subsetting. Multiple conditions can be combined with logical operators such as & (AND) and | (OR).\n\nExample 1.9 (Filtering Players with More than 200 At-Bats and More Than 20 Home Runs)  \n\nbatting_filtered_multiple = Batting |&gt;\n  filter(AB &gt; 200 & HR &gt; 20)\n\nhead(batting_filtered_multiple)\n\n   playerID yearID stint teamID lgID   G  AB   R   H X2B X3B HR RBI SB CS BB SO\n1 aaronha01   1955     1    ML1   NL 153 602 105 189  37   9 27 106  3  1 49 61\n2 aaronha01   1956     1    ML1   NL 153 609 106 200  34  14 26  92  2  4 37 54\n3 aaronha01   1957     1    ML1   NL 151 615 118 198  27   6 44 132  1  1 57 58\n4 aaronha01   1958     1    ML1   NL 153 601 109 196  34   4 30  95  4  1 59 49\n5 aaronha01   1959     1    ML1   NL 154 629 116 223  46   7 39 123  8  0 51 54\n6 aaronha01   1960     1    ML1   NL 153 590 102 172  20  11 40 126 16  7 60 63\n  IBB HBP SH SF GIDP\n1   5   3  7  4   20\n2   6   2  5  7   21\n3  15   0  0  3   13\n4  16   1  0  3   21\n5  17   4  0  9   19\n6  13   2  0 12    8\n\n\nHere, we use filter(AB &gt; 200 & HR &gt; 20) to select players who had more than 200 at-bats and also hit more than 20 home runs in a season. This type of filtering is useful for identifying high-performing players who both played regularly and demonstrated power-hitting ability.\n\n\n\n1.3.4 Filtering with Logical Operators\nYou can apply more complex logical conditions with filter(). For example, if you wanted to find players who either had more than 200 at-bats or hit more than 20 home runs (but not necessarily both), you could use the OR operator |.\n\nExample 1.10 (Using OR condition)  \n\nbatting_filtered_or = Batting |&gt;\n  filter(AB &gt; 200 | HR &gt; 20)\n\nhead(batting_filtered_or)\n\n   playerID yearID stint teamID lgID   G  AB   R   H X2B X3B HR RBI SB CS BB SO\n1 aaronha01   1954     1    ML1   NL 122 468  58 131  27   6 13  69  2  2 28 39\n2 aaronha01   1955     1    ML1   NL 153 602 105 189  37   9 27 106  3  1 49 61\n3 aaronha01   1956     1    ML1   NL 153 609 106 200  34  14 26  92  2  4 37 54\n4 aaronha01   1957     1    ML1   NL 151 615 118 198  27   6 44 132  1  1 57 58\n5 aaronha01   1958     1    ML1   NL 153 601 109 196  34   4 30  95  4  1 59 49\n6 aaronha01   1959     1    ML1   NL 154 629 116 223  46   7 39 123  8  0 51 54\n  IBB HBP SH SF GIDP\n1  NA   3  6  4   13\n2   5   3  7  4   20\n3   6   2  5  7   21\n4  15   0  0  3   13\n5  16   1  0  3   21\n6  17   4  0  9   19\n\n\nIn this example, players are included in the subset if they meet either of the conditions: more than 200 at-bats or more than 20 home runs.\n\n\n\n1.3.5 Using %in% to Filter by a Set of Values\nThe %in% operator can be used within filter() to check whether a column’s values belong to a specific set. This is particularly useful when you want to filter by specific categories, such as player IDs, teams, or years.\n\nExample 1.11 (Filtering Data for Specific Years) Let’s say you want to analyze data from only the 2010 and 2015 seasons.\n\nbatting_filtered_years = Batting |&gt;\n  filter(yearID %in% c(2010, 2015))\n\nhead(batting_filtered_years)\n\n   playerID yearID stint teamID lgID   G  AB  R   H X2B X3B HR RBI SB CS BB  SO\n1 aardsda01   2010     1    SEA   AL  53   0  0   0   0   0  0   0  0  0  0   0\n2 aardsda01   2015     1    ATL   NL  33   1  0   0   0   0  0   0  0  0  0   1\n3  abadfe01   2010     1    HOU   NL  22   1  0   0   0   0  0   0  0  0  0   1\n4  abadfe01   2015     1    OAK   AL  62   0  0   0   0   0  0   0  0  0  0   0\n5 abreubo01   2010     1    LAA   AL 154 573 88 146  41   1 20  78 24 10 87 132\n6 abreujo02   2015     1    CHA   AL 154 613 88 178  34   3 30 101  0  0 39 140\n  IBB HBP SH SF GIDP\n1   0   0  0  0    0\n2   0   0  0  0    0\n3   0   0  0  0    0\n4   0   0  0  0    0\n5   3   2  0  5   13\n6  11  15  0  1   16\n\n\nIn this example, we use filter(yearID %in% c(2010, 2015)) to retain only the rows where the yearID column matches 2010 or 2015. This approach is helpful when working with data from specific seasons or games.\n\n\n\n1.3.6 Filtering Missing Data\nIn many datasets, missing values (represented as NA in R) can cause problems if not handled properly. You can use filter() to exclude rows with missing values or to isolate rows where certain values are missing.\n\nExample 1.12 (Filtering Out Missing Data) Let’s filter out rows where the number of at-bats (AB) is missing.\n\n# Removing rows with missing values for at-bats\nbatting_no_na = Batting |&gt;\n  filter(!is.na(AB))\n\nhead(batting_no_na)\n\n   playerID yearID stint teamID lgID  G AB R H X2B X3B HR RBI SB CS BB SO IBB\n1 aardsda01   2004     1    SFN   NL 11  0 0 0   0   0  0   0  0  0  0  0   0\n2 aardsda01   2006     1    CHN   NL 45  2 0 0   0   0  0   0  0  0  0  0   0\n3 aardsda01   2007     1    CHA   AL 25  0 0 0   0   0  0   0  0  0  0  0   0\n4 aardsda01   2008     1    BOS   AL 47  1 0 0   0   0  0   0  0  0  0  1   0\n5 aardsda01   2009     1    SEA   AL 73  0 0 0   0   0  0   0  0  0  0  0   0\n6 aardsda01   2010     1    SEA   AL 53  0 0 0   0   0  0   0  0  0  0  0   0\n  HBP SH SF GIDP\n1   0  0  0    0\n2   0  1  0    0\n3   0  0  0    0\n4   0  0  0    0\n5   0  0  0    0\n6   0  0  0    0\n\n\nHere, we use filter(!is.na(AB)) to remove rows where the value for at-bats (AB) is missing (NA). This ensures that we are working only with complete data.\n\nThe filter() function is an indispensable tool for narrowing down large datasets based on specific criteria. Whether you’re filtering by player performance, season, or game outcomes, filter() allows you to extract just the rows that are most relevant to your analysis. In sports analytics, this enables you to focus on specific players, teams, or metrics that drive meaningful insights.\nIn the next section, we will explore how to use the summarise() function to aggregate data, such as calculating team-level statistics or summarizing player performance over a season or career."
  },
  {
    "objectID": "01_Intro.html#using-summarise-to-aggregate-data",
    "href": "01_Intro.html#using-summarise-to-aggregate-data",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.4 Using summarise() to Aggregate Data",
    "text": "1.4 Using summarise() to Aggregate Data\nThe summarise() function in dplyr is used to create summary statistics from your dataset by collapsing multiple rows into a single value. This function is essential in sports analytics, where you often need to aggregate data to calculate overall metrics, such as total points, average performance statistics, or team-level summaries. With summarise(), you can compute a wide variety of statistics such as sums, averages, minimums, and maximums, allowing for powerful aggregation of data.\n\n1.4.1 Syntax\nThe basic syntax of summarise() is as follows:\ndata |&gt; \n  summarise(new_summary = aggregation_function(column))\nWhere:\n\ndata is the dataset.\nnew_summary is the name of the new summary statistic.\naggregation_function(column) is the function applied to the column you want to summarize (e.g., mean(), sum(), min(), max()).\n\n\n\n1.4.2 Why Use summarise()?\nIn sports analytics, it is often necessary to calculate overall performance metrics, such as:\n\nSumming a player’s total points over multiple seasons.\nCalculating a team’s average points per game.\nAggregating player data to find league-wide averages or totals.\nComputing summary statistics like the highest or lowest scoring games in a season.\n\nUsing summarise(), you can efficiently compute these summary statistics and gain high-level insights from raw data.\n\n\n1.4.3 Grouping Data Before Summarizing\nWhen using summarise(), it’s common to group data by one or more variables before applying the summary function. This is achieved with the group_by() function, which allows you to summarize data across different categories, such as by player, team, or season.\nFor example:\n\nSummarizing total points per player across multiple games.\nCalculating the average performance metrics per team in a season.\nAggregating statistics by season to track trends over time.\n\n\nExample 1.13 (Summarizing Total Home Runs per Year) Let’s use the Lahman dataset to calculate the total number of home runs hit by all players for each year. First, we will group the data by year and then use summarise() to compute the total home runs.\n\nlibrary(dplyr)\nlibrary(Lahman)\n\n# Summarizing total home runs per year\nhome_runs_per_year &lt;- Batting |&gt;\n  group_by(yearID) |&gt;\n  summarise(total_HR = sum(HR, na.rm = TRUE))\n\nhead(home_runs_per_year)\n\n# A tibble: 6 × 2\n  yearID total_HR\n   &lt;int&gt;    &lt;int&gt;\n1   1871       47\n2   1872       37\n3   1873       47\n4   1874       40\n5   1875       40\n6   1876       40\n\n\nIn this example, we first use group_by(yearID) to group the data by year, and then summarise() is used to compute the total number of home runs (HR) hit in each year. The na.rm = TRUE argument ensures that missing values are ignored during the summation. This type of summary can help analyze trends in home run performance over time.\n\n\nExample 1.14 (Calculating Average Batting Average per Year) You can also calculate averages using summarise(). Let’s calculate the average batting average (BA) for each year by grouping the data by yearID and then using the mean() function within summarise().\n\n# Calculating average batting average per year\nbatting_average_per_year &lt;- Batting |&gt;\n  group_by(yearID) |&gt;\n  summarise(avg_BA = mean(H / AB, na.rm = TRUE))\n\nhead(batting_average_per_year)\n\n# A tibble: 6 × 2\n  yearID avg_BA\n   &lt;int&gt;  &lt;dbl&gt;\n1   1871  0.254\n2   1872  0.246\n3   1873  0.252\n4   1874  0.240\n5   1875  0.218\n6   1876  0.211\n\n\nIn this example, we compute the average batting average (avg_BA) for each year. The mean() function calculates the average of hits divided by at-bats, and na.rm = TRUE ensures that missing data is handled appropriately.\n\n\nMultiple Summaries with summarise()\nYou can compute multiple summary statistics in a single summarise() call by simply listing additional summary expressions separated by commas.\n\nExample 1.15 (Summarizing Both Total and Average Home Runs per Year)  \n\n# Summarizing total and average home runs per year\nhome_run_stats &lt;- Batting |&gt;\n  group_by(yearID) |&gt;\n  summarise(total_HR = sum(HR, na.rm = TRUE),\n            avg_HR = mean(HR, na.rm = TRUE))\n\nhead(home_run_stats)\n\n# A tibble: 6 × 3\n  yearID total_HR avg_HR\n   &lt;int&gt;    &lt;int&gt;  &lt;dbl&gt;\n1   1871       47  0.409\n2   1872       37  0.236\n3   1873       47  0.376\n4   1874       40  0.325\n5   1875       40  0.184\n6   1876       40  0.323\n\n\nIn this example, we calculate both the total home runs (total_HR) and the average home runs per player (avg_HR) for each year. This provides both a high-level view (total) and a per-player perspective (average) of home run performance.\n\n\n\n\n1.4.4 Adding Summary Statistics to the Original Data\nIn some cases, you may want to add summary statistics back to your original dataset. This can be achieved by combining mutate() with summarise() to append calculated statistics to each row.\n\nExample 1.16 (Adding Average Points per Player to Each Team)  \n\nlibrary(hoopR)\n\n#load the data for 2023\nbasketball_data = load_nba_player_box(seasons = 2023)\n\n\nnba_stats = basketball_data |&gt;\n  group_by(team_name) |&gt; \n  summarize(avg_pts_team = mean(points, na.rm = TRUE)) |&gt; \n  right_join(basketball_data, by = \"team_name\")\n\nhead(nba_stats)\n\n# A tibble: 6 × 58\n  team_name avg_pts_team   game_id season season_type game_date \n  &lt;chr&gt;            &lt;dbl&gt;     &lt;int&gt;  &lt;int&gt;       &lt;int&gt; &lt;date&gt;    \n1 76ers             10.5 401545117   2023           3 2023-05-14\n2 76ers             10.5 401545117   2023           3 2023-05-14\n3 76ers             10.5 401545117   2023           3 2023-05-14\n4 76ers             10.5 401545117   2023           3 2023-05-14\n5 76ers             10.5 401545117   2023           3 2023-05-14\n6 76ers             10.5 401545117   2023           3 2023-05-14\n# ℹ 52 more variables: game_date_time &lt;dttm&gt;, athlete_id &lt;int&gt;,\n#   athlete_display_name &lt;chr&gt;, team_id &lt;int&gt;, team_location &lt;chr&gt;,\n#   team_short_display_name &lt;chr&gt;, minutes &lt;dbl&gt;, field_goals_made &lt;int&gt;,\n#   field_goals_attempted &lt;int&gt;, three_point_field_goals_made &lt;int&gt;,\n#   three_point_field_goals_attempted &lt;int&gt;, free_throws_made &lt;int&gt;,\n#   free_throws_attempted &lt;int&gt;, offensive_rebounds &lt;int&gt;,\n#   defensive_rebounds &lt;int&gt;, rebounds &lt;int&gt;, assists &lt;int&gt;, steals &lt;int&gt;, …\n\n\nIn this example, we first calculate the average points per team (avg_pts_team) and then use right_join() to merge this summary statistic back into the original dataset, so that each player’s row now contains their team’s average points.\n\nThe summarise() function is a critical tool for aggregating and summarizing data in sports analytics. Whether you’re calculating total points, average performance metrics, or team-level statistics, summarise() allows you to collapse large datasets into meaningful summary statistics. By combining summarise() with group_by(), you can gain insights into trends across seasons, teams, or players, providing a comprehensive view of the data.\nIn the next section, we’ll explore the arrange() function, which is used to order and rank your data, making it easier to identify top performers and trends."
  },
  {
    "objectID": "01_Intro.html#using-arrange-to-order-rows",
    "href": "01_Intro.html#using-arrange-to-order-rows",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.5 Using arrange() to Order Rows",
    "text": "1.5 Using arrange() to Order Rows\nThe arrange() function in dplyr is used to reorder the rows of a dataset based on the values of one or more variables. This function is particularly useful in sports analytics when you want to rank players or teams according to performance metrics, such as points scored, assists made, or wins achieved. By using arrange(), you can quickly identify top performers, sort data chronologically, or rank teams based on standings.\n\n1.5.1 Syntax\nThe basic syntax of arrange() is as follows:\ndata |&gt; \n  arrange(column1, column2, ...)\nWhere:\n\ndata is the dataset.\ncolumn1, column2, etc., are the columns by which the data should be ordered.\n\nBy default, arrange() sorts the rows in ascending order. To sort in descending order, you can wrap the column name in desc().\n\n\n1.5.2 Why Use arrange()?\nIn sports analytics, ranking and sorting data is a common task. Whether you’re determining the highest scorers, ordering teams by win percentage, or ranking players by efficiency, arrange() allows you to easily reorder your data to facilitate comparisons and insights.\nFor example, you may want to:\n\nRank basketball players by points scored per game.\nSort baseball teams by total wins.\nRank athletes by efficiency ratings, from highest to lowest.\n\n\nExample 1.17 (Arranging by Batting Average) Let’s use the Lahman dataset again and sort the players by their batting average (BA). First, we need to calculate the batting average using mutate() and then sort the dataset in descending order to identify the top performers.\n\nlibrary(dplyr)\nlibrary(Lahman)\n\nbatting_data &lt;- Batting |&gt;\n  mutate(BA = H / AB) |&gt;\n  arrange(desc(BA))\n\nhead(batting_data)\n\n   playerID yearID stint teamID lgID G AB R H X2B X3B HR RBI SB CS BB SO IBB\n1  aberal01   1957     2    KC1   AL 3  1 0 1   0   0  0   0  0  0  0  0   0\n2 abernte02   1960     1    WS1   AL 2  1 1 1   0   0  0   0  0  0  0  0   0\n3 abramge01   1923     1    CIN   NL 3  1 0 1   0   0  0   0  0  0  0  0  NA\n4 acklefr01   1964     1    CHA   AL 3  1 0 1   1   0  0   1  0  0  1  0   0\n5 alanirj01   2019     2    CIN   NL 8  1 0 1   0   0  0   1  0  0  0  0   0\n6 alberan01   2017     1    SEA   AL 9  1 0 1   0   0  0   1  0  0  0  0   0\n  HBP SH SF GIDP BA\n1   0  0  0    0  1\n2   0  0  0    0  1\n3   0  0 NA   NA  1\n4   0  0  0    0  1\n5   0  0  0    0  1\n6   0  2  0    0  1\n\n\nIn this example, we first calculate the batting average (BA) using mutate() and then use arrange(desc(BA)) to sort the data in descending order of batting average. This allows us to see the players with the highest batting averages at the top of the dataset.\n\n\n\n1.5.3 Arranging by Multiple Variables\nYou can also sort data by multiple columns. For example, if two players have the same batting average, you might want to break the tie by looking at their home run totals.\n\nExample 1.18 (Arranging by Batting Average and Home Runs)  \n\nbatting_data_sorted &lt;- Batting |&gt;\n  mutate(BA = H / AB) |&gt;\n  arrange(desc(BA), desc(HR))\n\nhead(batting_data_sorted)\n\n   playerID yearID stint teamID lgID  G AB R H X2B X3B HR RBI SB CS BB SO IBB\n1 chacigu01   2010     1    HOU   NL 44  1 1 1   0   0  1   1  0  0  0  0   0\n2 hernafe02   2008     1    SEA   AL 31  1 1 1   0   0  1   4  0  0  0  0   0\n3 jimerch01   2007     1    SEA   AL 11  2 5 2   0   0  1   1  2  0  0  0   0\n4 lefebbi01   1938     1    BOS   AL  1  1 1 1   0   0  1   1  0  0  0  0  NA\n5  motagu01   1999     1    MON   NL 51  1 1 1   0   0  1   3  0  0  0  0   0\n6 narumbu01   1963     1    BAL   AL  7  1 1 1   0   0  1   2  0  0  0  0   0\n  HBP SH SF GIDP BA\n1   0  0  0    0  1\n2   0  1  0    0  1\n3   0  0  0    0  1\n4   0  0 NA   NA  1\n5   0  0  0    0  1\n6   0  0  0    0  1\n\n\nHere, we first sort by batting average (BA) in descending order, and in the case of ties, we further arrange the rows by home runs (HR) in descending order. This type of multi-variable sorting is useful for resolving ties or ranking data based on multiple criteria.\n\n\n\n1.5.4 Sorting Chronologically\nIn many sports datasets, you might want to sort data chronologically to observe trends over time. This can be done by arranging data by a date or year variable.\n\nExample 1.19 (Sorting by Year) Let’s sort the ‘Lahman’ dataset by the yearID variable to view the data in chronological order.\n\nbatting_data_by_year &lt;- Batting |&gt;\n  arrange(desc(yearID))\n\nhead(batting_data_by_year)\n\n   playerID yearID stint teamID lgID   G  AB  R   H X2B X3B HR RBI SB CS BB  SO\n1  abadfe01   2023     1    COL   NL   6   0  0   0   0   0  0   0  0  0  0   0\n2 abbotan01   2023     1    CIN   NL  21   0  0   0   0   0  0   0  0  0  0   0\n3 abbotco01   2023     1    WAS   NL  22   0  0   0   0   0  0   0  0  0  0   0\n4 abramcj01   2023     1    WAS   NL 151 563 83 138  28   6 18  64 47  4 32 118\n5 abreual01   2023     1    NYA   AL  45   0  0   0   0   0  0   0  0  0  0   0\n6 abreubr01   2023     1    HOU   AL  72   0  0   0   0   0  0   0  0  0  0   0\n  IBB HBP SH SF GIDP\n1   0   0  0  0    0\n2   0   0  0  0    0\n3   0   0  0  0    0\n4   2  13  3  3    7\n5   0   0  0  0    0\n6   0   0  0  0    0\n\n\nThis example sorts the data in ascending order by yearID, allowing us to see the dataset arranged chronologically by season. Sorting by year or date is especially useful when analyzing time trends in performance or observing how a player’s career evolves over time.\n\nThe arrange() function is a valuable tool in sports analytics for ordering and ranking data. Whether you’re sorting players by performance metrics, ranking teams based on wins, or organizing data chronologically, arrange() allows you to structure your data in a way that facilitates meaningful analysis. You can arrange data by one or more columns, and by using desc(), you can sort in descending order to prioritize top performers."
  },
  {
    "objectID": "01_Intro.html#concept-quiz",
    "href": "01_Intro.html#concept-quiz",
    "title": "1  Intro to Data Manipulation with dplyr",
    "section": "1.6 Concept Quiz",
    "text": "1.6 Concept Quiz\n\nWhat is the primary function of the mutate() function in dplyr?\n\n To summarize data into a single value To filter rows based on a condition To select specific columns To add or transform variables\n\nWhich function in dplyr is used to select specific columns from a dataset?\n\n mutate() arrange() filter() select()\n\nIn the context of the mutate() function, what would happen if you attempt to divide a value by zero without handling it?\n\n It would result in an error. It would remove the row. The value would be set to NA. The value would be automatically set to zero.\n\nWhich of the following functions is used to reorder rows in a dataset?\n\n summarise() mutate() filter() arrange()\n\nTo extract rows of data that meet specific conditions, such as “players with more than 200 at-bats”, which function would you use?\n\n mutate() filter() arrange() summarise()\n\nTrue or False: The select() function allows you to drop specific columns by prefixing their names with a minus sign (-). TRUEFALSE\nTrue or False: In the filter() function, using & combines conditions in such a way that both conditions must be true for a row to be included in the subset. TRUEFALSE\nTrue or False: The arrange() function in dplyr can only sort data in ascending order. TRUEFALSE"
  },
  {
    "objectID": "02_Stringr.html",
    "href": "02_Stringr.html",
    "title": "2  String, Dates, and Joins",
    "section": "",
    "text": "3 String Manipulation and Working with Dates in Sports Analytics\nThis section demonstrates how to manage and analyze sports data using string manipulation and date-time operations. We’ll explore tools from the tidyverse in R, using basketball-related datasets like pgfreethrow.csv and other datasets available in R packages."
  },
  {
    "objectID": "02_Stringr.html#string-manipulation",
    "href": "02_Stringr.html#string-manipulation",
    "title": "2  String, Dates, and Joins",
    "section": "2.1 String Manipulation",
    "text": "2.1 String Manipulation\nString manipulation is essential when handling categorical data or extracting information embedded within text. Using the stringr package from tidyverse, we can efficiently handle text data. This includes cleaning up inconsistent formatting, extracting specific patterns, and transforming data into analyzable formats. For example, when dealing with play results, you might need to distinguish between various outcomes or classify performance metrics based on embedded textual descriptions.\nEfficient string manipulation also allows for seamless preprocessing of large datasets, ensuring that raw, unstructured text data can be transformed into usable forms. With tools like regular expressions and the functionality of stringr, you can extract numerical details from text, standardize categories, and even generate new variables based on patterns within your data. These transformations are vital for downstream analyses, including statistical modeling and visualization.\nMoreover, combining stringr with other tidyverse functions facilitates a unified workflow. This integration ensures that data wrangling and string processing can occur in a pipeline, reducing redundancy and enhancing reproducibility in sports analytics projects.\n\n2.1.1 Common stringr Functions\nThe stringr package provides a comprehensive set of tools for text manipulation. Below are some commonly used functions:\n\nstr_detect(): Checks for the presence of a pattern in a string and returns a logical value. This is useful for categorizing or flagging data based on text content.\nstr_extract(): Extracts the first occurrence of a specified pattern. Ideal for pulling out specific details like numbers or substrings embedded in text.\nstr_replace(): Replaces occurrences of a pattern with a new string. Useful for standardizing text formats or correcting inconsistencies.\nstr_split(): Splits strings into components based on a delimiter. This is helpful when parsing structured text like CSV fields embedded in a string.\nstr_length(): Returns the number of characters in a string. Useful for quality checks or trimming operations.\n\nBy leveraging these string manipulation methods, analysts can address challenges like inconsistent data entry or embedded patterns within text. These methods not only enhance the quality of the dataset but also open up possibilities for deeper and more nuanced analyses. Ultimately, they enable a smoother transition from raw data to actionable insights, which is especially critical in high-volume datasets.\n\nExample 2.1 (Determine Free Throw Outcome) The pgfreethrow.csv dataset contains free throws shot by Paul George during his career through the 2021-2022 season. The data was obtained from https://www.basketball-reference.com. The data contains a column playresult, which logs whether a free throw is a Make or a Miss along with the shot number. We’ll extract and classify this information but first let’s examine the dataset.\n\nlibrary(tidyverse)\n\ndat = read_csv(\"data/pgfreethrow.csv\")\n\ndat |&gt; glimpse()\n\nRows: 4,170\nColumns: 9\n$ date       &lt;chr&gt; \"10/27/2010\", \"10/27/2010\", \"11/9/2010\", \"11/9/2010\", \"11/1…\n$ vis_team   &lt;chr&gt; \"Indiana Pacers\", \"Indiana Pacers\", \"Denver Nuggets\", \"Denv…\n$ home_team  &lt;chr&gt; \"San Antonio Spurs\", \"San Antonio Spurs\", \"Indiana Pacers\",…\n$ quarter    &lt;chr&gt; \"3\", \"3\", \"4\", \"4\", \"4\", \"1\", \"1\", \"3\", \"2\", \"2\", \"3\", \"3\",…\n$ time       &lt;time&gt; 04:26:00, 04:26:00, 06:50:00, 06:50:00, 00:26:00, 00:38:00…\n$ court      &lt;chr&gt; \"away\", \"away\", \"home\", \"home\", \"home\", \"home\", \"home\", \"ho…\n$ playresult &lt;chr&gt; \"makes free throw 1 of 2\", \"makes free throw 2 of 2\", \"miss…\n$ away_score &lt;dbl&gt; 83, 84, 93, 93, 78, 20, 20, 47, 30, 30, 76, 77, 80, 81, 106…\n$ home_score &lt;dbl&gt; 81, 81, 124, 125, 107, 24, 25, 67, 24, 25, 77, 77, 77, 77, …\n\n\nWe first want to determine if the free throw attempt was a Make or a Miss. We can use str_detect in combination with if_else.\n\n# Determine the outcome of each free throw\ndat = dat |&gt;\n  mutate(\n    outcome = if_else(str_detect(playresult, \"make\"), \"make\", \"miss\")\n  )\n\ndat |&gt; glimpse()\n\nRows: 4,170\nColumns: 10\n$ date       &lt;chr&gt; \"10/27/2010\", \"10/27/2010\", \"11/9/2010\", \"11/9/2010\", \"11/1…\n$ vis_team   &lt;chr&gt; \"Indiana Pacers\", \"Indiana Pacers\", \"Denver Nuggets\", \"Denv…\n$ home_team  &lt;chr&gt; \"San Antonio Spurs\", \"San Antonio Spurs\", \"Indiana Pacers\",…\n$ quarter    &lt;chr&gt; \"3\", \"3\", \"4\", \"4\", \"4\", \"1\", \"1\", \"3\", \"2\", \"2\", \"3\", \"3\",…\n$ time       &lt;time&gt; 04:26:00, 04:26:00, 06:50:00, 06:50:00, 00:26:00, 00:38:00…\n$ court      &lt;chr&gt; \"away\", \"away\", \"home\", \"home\", \"home\", \"home\", \"home\", \"ho…\n$ playresult &lt;chr&gt; \"makes free throw 1 of 2\", \"makes free throw 2 of 2\", \"miss…\n$ away_score &lt;dbl&gt; 83, 84, 93, 93, 78, 20, 20, 47, 30, 30, 76, 77, 80, 81, 106…\n$ home_score &lt;dbl&gt; 81, 81, 124, 125, 107, 24, 25, 67, 24, 25, 77, 77, 77, 77, …\n$ outcome    &lt;chr&gt; \"make\", \"make\", \"miss\", \"make\", \"make\", \"make\", \"make\", \"ma…\n\n\n\n\n\n2.1.2 Regular Expressions\nRegular expressions (regex) are a powerful tool for identifying patterns in text. They allow you to define complex search patterns using a concise syntax, making them ideal for string extraction, validation, and manipulation. In R, the stringr package seamlessly integrates regex functionality, enabling analysts to perform advanced text operations efficiently.\nFor example, a regex pattern like \"\\\\d of \\\\d\" can identify phrases like “1 of 2” in a dataset, extracting structured information embedded within text fields. Regex is particularly useful for parsing datasets with varying formats or extracting subsets of data based on specific conditions. Combined with stringr functions like str_detect, str_extract, and str_replace, regex becomes an essential part of your data preprocessing toolkit.\nWhile regex might seem daunting at first, breaking patterns into smaller components and testing them incrementally can make them more approachable. Mastery of regex not only improves data cleaning workflows but also enhances the accuracy and depth of data extraction, empowering analysts to unlock insights that would otherwise remain hidden.\n\nCommon regex patterns\nHere are some commonly used regex patterns and their functions:\n\n^: Matches the start of a string. Useful for identifying strings that begin with a specific pattern. Example: ^Make matches any string starting with “Make”.\n$: Matches the end of a string. Useful for ensuring a string concludes with a particular sequence. Example: 2$ matches strings ending in “2”.\n.: Matches any single character except a newline. This is helpful for flexible matching. Example: M.ke matches “Make”, “Mike”, or “Moke”.\n\\d: Matches any digit. Useful for extracting numeric values. Example: \\d of \\d matches strings like “1 of 2”.\n[]: Matches any character inside the brackets. Use this to define a character set. Example: [Mm]ake matches “Make” and “make”.\n+: Matches one or more occurrences of the preceding element. Example: \\d+ matches any sequence of digits, such as “123” or “7”.\n\nBy combining these patterns, you can create robust expressions for almost any text-processing need. Regular expressions are incredibly versatile and, when used effectively, can transform the way you handle text data.\n\n\nMore examples\nHere are additional examples of regex applications using some simple toy datasets.\n\nExtract Player Names\nSuppose we have player names in the format “Last, First”. Using regex, we can separate them into first and last names.\n\nplayers = tibble(name = c(\"James, LeBron\", \"Curry, Stephen\", \"Durant, Kevin\"))\n\nplayers = players |&gt;\n  mutate(\n    first_name = str_extract(name, \"(?&lt;=, ).*\"),\n    last_name = str_extract(name, \"^.*(?=,)\")\n  )\n\nplayers\n\n# A tibble: 3 × 3\n  name           first_name last_name\n  &lt;chr&gt;          &lt;chr&gt;      &lt;chr&gt;    \n1 James, LeBron  LeBron     James    \n2 Curry, Stephen Stephen    Curry    \n3 Durant, Kevin  Kevin      Durant   \n\n\nIdentify Scoring Plays\nIn game logs, scoring plays may include text like “scores 3 points” or “makes a free throw”. Use regex to flag all scoring events.\n\nplays = tibble(event = c(\"LeBron scores 3 points\", \"Curry makes a free throw\", \"Durant misses shot\"))\n\nplays = plays |&gt;\n  mutate(scoring = str_detect(event, \"scores|makes\"))\n\nplays\n\n# A tibble: 3 × 2\n  event                    scoring\n  &lt;chr&gt;                    &lt;lgl&gt;  \n1 LeBron scores 3 points   TRUE   \n2 Curry makes a free throw TRUE   \n3 Durant misses shot       FALSE  \n\n\nParse Complex IDs\nFor datasets with IDs like “P123-456-789”, extract the numeric components for further analysis.\n\nids = tibble(player_id = c(\"P123-456-789\", \"P987-654-321\"))\n\nids = ids |&gt;\n  mutate(\n    part1 = str_extract(player_id, \"(?&lt;=P)\\\\d+\"),\n    part2 = str_extract(player_id, \"(?&lt;=-)\\\\d+(?=-)\"),\n    part3 = str_extract(player_id, \"\\\\d+$\")\n  )\n\nids\n\n# A tibble: 2 × 4\n  player_id    part1 part2 part3\n  &lt;chr&gt;        &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 P123-456-789 123   456   789  \n2 P987-654-321 987   654   321"
  },
  {
    "objectID": "02_Stringr.html#working-with-dates",
    "href": "02_Stringr.html#working-with-dates",
    "title": "2  String, Dates, and Joins",
    "section": "2.2 Working with Dates",
    "text": "2.2 Working with Dates\nAnalyzing performance trends often involves working with date-time variables. Dates might be stored as text, requiring conversion to a proper date format.\n\n2.2.1 Common lubridate Functions\nThe lubridate package is an essential tool in R for working with date and time data. Below are some of the most commonly used functions and their applications:\n\nymd() / mdy() / dmy(): These functions parse text strings into date objects, assuming the formats “Year-Month-Day”, “Month-Day-Year”, or “Day-Month-Year”, respectively.\nExample:\n\nymd(\"2023-12-29\")  # Returns a date object: \"2023-12-29\"\n\n[1] \"2023-12-29\"\n\nmdy(\"12-29-2023\")  # Returns a date object: \"2023-12-29\"\n\n[1] \"2023-12-29\"\n\n\nyear(), month(), day(): Extract specific components (year, month, or day) from a date object. The month() function can also return month names if label = TRUE is used.\nExample:\n\ndate = ymd(\"2023-12-29\")\nyear(date)   \n\n[1] 2023\n\nmonth(date)  \n\n[1] 12\n\nday(date)    \n\n[1] 29\n\n\nhour(), minute(), second(): Extract time components from a datetime object.\nExample:\n\ndatetime = ymd_hms(\"2023-12-29 15:45:30\")\nhour(datetime)  \n\n[1] 15\n\nminute(datetime) \n\n[1] 45\n\nsecond(datetime)\n\n[1] 30\n\n\ntoday() and now(): Retrieve the current date or datetime in the system’s timezone.\nExample:\n\ntoday()  \n\n[1] \"2025-01-22\"\n\nnow()  \n\n[1] \"2025-01-22 10:50:56 CST\"\n\n\nfloor_date(), ceiling_date(), round_date(): Round dates to the nearest unit such as day, month, or year.\nExample:\n\ndate = ymd(\"2023-12-29\")\nfloor_date(date, \"month\")  \n\n[1] \"2023-12-01\"\n\nceiling_date(date, \"month\")  \n\n[1] \"2024-01-01\"\n\n\ninterval() and duration(): Create and manipulate intervals or durations. These functions are useful for calculating time differences.\nExample:\n\nstart = ymd(\"2023-01-01\")\nend = ymd(\"2023-12-31\")\nint = interval(start, end)\nint_shift(int, duration(days = 14))\n\n[1] 2023-01-15 UTC--2024-01-14 UTC\n\n\n\nBy understanding and using these functions, you can seamlessly handle date-time data in sports analytics, enabling you to analyze performance trends, calculate durations, and identify patterns over time.\n\nExample 2.2 (Converting to dates)  \n\nlibrary(lubridate)\n\n# Convert game_date to Date type\ndat = dat |&gt;\n  mutate(date = mdy(date))\n\n# Display the structure of the dataset\ndat |&gt; glimpse()\n\nRows: 4,170\nColumns: 10\n$ date       &lt;date&gt; 2010-10-27, 2010-10-27, 2010-11-09, 2010-11-09, 2010-11-18…\n$ vis_team   &lt;chr&gt; \"Indiana Pacers\", \"Indiana Pacers\", \"Denver Nuggets\", \"Denv…\n$ home_team  &lt;chr&gt; \"San Antonio Spurs\", \"San Antonio Spurs\", \"Indiana Pacers\",…\n$ quarter    &lt;chr&gt; \"3\", \"3\", \"4\", \"4\", \"4\", \"1\", \"1\", \"3\", \"2\", \"2\", \"3\", \"3\",…\n$ time       &lt;time&gt; 04:26:00, 04:26:00, 06:50:00, 06:50:00, 00:26:00, 00:38:00…\n$ court      &lt;chr&gt; \"away\", \"away\", \"home\", \"home\", \"home\", \"home\", \"home\", \"ho…\n$ playresult &lt;chr&gt; \"makes free throw 1 of 2\", \"makes free throw 2 of 2\", \"miss…\n$ away_score &lt;dbl&gt; 83, 84, 93, 93, 78, 20, 20, 47, 30, 30, 76, 77, 80, 81, 106…\n$ home_score &lt;dbl&gt; 81, 81, 124, 125, 107, 24, 25, 67, 24, 25, 77, 77, 77, 77, …\n$ outcome    &lt;chr&gt; \"make\", \"make\", \"miss\", \"make\", \"make\", \"make\", \"make\", \"ma…\n\n\n\nSuppose we want to determine if Paul George has different free throw percentages for different months of the year. Let’s extract the month component of the date so that we can summarize.\n\nExample 2.3 (Extract Year and Month)  \n\n# Extract year and month\ndat = dat |&gt;\n  mutate(\n    year = year(date),\n    month = month(date, label = TRUE)\n  )\n\n# Summarize free throw percentages by month\ndat_summary = dat |&gt;\n  group_by(month) |&gt;\n  summarize(\n    total_shots = n(),\n    makes = sum(outcome == \"make\"),\n    free_throw_percentage = makes / total_shots * 100\n  )\n\n# Display summary\ndat_summary\n\n# A tibble: 12 × 4\n   month total_shots makes free_throw_percentage\n   &lt;ord&gt;       &lt;int&gt; &lt;int&gt;                 &lt;dbl&gt;\n 1 Jan           642   545                  84.9\n 2 Feb           513   434                  84.6\n 3 Mar           695   583                  83.9\n 4 Apr           598   507                  84.8\n 5 May           257   197                  76.7\n 6 Jun           143   117                  81.8\n 7 Jul             4     2                  50  \n 8 Aug            48    44                  91.7\n 9 Sep            33    29                  87.9\n10 Oct           127   105                  82.7\n11 Nov           479   411                  85.8\n12 Dec           631   544                  86.2\n\n\nBy exploring free throw performance by month, we can identify seasonal trends or patterns in player accuracy. Understanding such patterns can be invaluable for game preparation and performance analysis."
  },
  {
    "objectID": "02_Stringr.html#combining-data-frames",
    "href": "02_Stringr.html#combining-data-frames",
    "title": "2  String, Dates, and Joins",
    "section": "2.3 Combining Data Frames",
    "text": "2.3 Combining Data Frames\nIn sports analytics, combining datasets is often necessary to enrich analyses by merging relevant data sources. The dplyr package in R provides several join functions to combine data frames based on common columns (keys). These include:\n\n2.3.1 Types of Joins\n\ninner_join(): Returns rows with matching keys in both data frames.\nleft_join(): Returns all rows from the first data frame and matching rows from the second data frame.\nright_join(): Returns all rows from the second data frame and matching rows from the first data frame.\nfull_join(): Returns all rows from both data frames, with NA for unmatched rows.\nsemi_join(): Filters rows from the first data frame that have matches in the second data frame but doesn’t include columns from the second data frame.\nanti_join(): Filters rows from the first data frame that do not have matches in the second data frame.\n\n\n\n2.3.2 Examples: Combining Basketball Data\nLet’s illustrate these joins using two basketball-related datasets:\n\nplayers contains player names and their team IDs.\nteams contains team IDs and their names.\n\n\nThe Data\n\nplayers &lt;- tibble(\n  player_id = 1:4,\n  player_name = c(\"LeBron James\", \"Stephen Curry\", \"Kevin Durant\", \"Chris Paul\"),\n  team_id = c(1, 2, 3, 4)\n)\n\nteams &lt;- tibble(\n  team_id = c(1, 2, 3, 5),\n  team_name = c(\"Lakers\", \"Warriors\", \"Nets\", \"Knicks\")\n)\n\n\n\nInner Join\nKeeps only players with matching team IDs in the teams table.\n\ninner_join(players, teams, by = \"team_id\")\n\n# A tibble: 3 × 4\n  player_id player_name   team_id team_name\n      &lt;int&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;    \n1         1 LeBron James        1 Lakers   \n2         2 Stephen Curry       2 Warriors \n3         3 Kevin Durant        3 Nets     \n\n\n\n\nLeft Join\nKeeps all players, adding team names where possible.\n\nleft_join(players, teams, by = \"team_id\")\n\n# A tibble: 4 × 4\n  player_id player_name   team_id team_name\n      &lt;int&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;    \n1         1 LeBron James        1 Lakers   \n2         2 Stephen Curry       2 Warriors \n3         3 Kevin Durant        3 Nets     \n4         4 Chris Paul          4 &lt;NA&gt;     \n\n\n\n\nFull Join\nCombines all rows from both datasets.\n\nfull_join(players, teams, by = \"team_id\")\n\n# A tibble: 5 × 4\n  player_id player_name   team_id team_name\n      &lt;int&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;    \n1         1 LeBron James        1 Lakers   \n2         2 Stephen Curry       2 Warriors \n3         3 Kevin Durant        3 Nets     \n4         4 Chris Paul          4 &lt;NA&gt;     \n5        NA &lt;NA&gt;                5 Knicks   \n\n\n\n\nSemi Join\nFilters players to include only those on teams listed in teams.\n\nsemi_join(players, teams, by = \"team_id\")\n\n# A tibble: 3 × 3\n  player_id player_name   team_id\n      &lt;int&gt; &lt;chr&gt;           &lt;dbl&gt;\n1         1 LeBron James        1\n2         2 Stephen Curry       2\n3         3 Kevin Durant        3\n\n\n\n\nAnti Join\nFilters players to include only those not matched in teams.\n\nanti_join(players, teams, by = \"team_id\")\n\n# A tibble: 1 × 3\n  player_id player_name team_id\n      &lt;int&gt; &lt;chr&gt;         &lt;dbl&gt;\n1         4 Chris Paul        4\n\n\nUnderstanding and using these joins effectively is critical for analyzing sports data where relationships between entities, such as players and teams, are vital."
  },
  {
    "objectID": "02_Stringr.html#concept-quiz",
    "href": "02_Stringr.html#concept-quiz",
    "title": "2  String, Dates, and Joins",
    "section": "2.4 Concept Quiz",
    "text": "2.4 Concept Quiz\n\nWhat function in stringr is used to detect the presence of a pattern in a string?\n\n str_length() str_replace() str_detect() str_extract()\n\nWhat is the purpose of the str_replace() function?\n\n Check if a pattern exists in a string Replace occurrences of a pattern in a string Count characters in a string Extract substrings from text\n\nWhat regex pattern matches one or more digits?\n\n \\d+ [0-9] [a-zA-Z] \\d*\n\nWhich lubridate function parses dates in the format “Year-Month-Day”?\n\n dmy() mdy() parse_date() ymd()\n\nWhat does the interval() function in lubridate do?\n\n Parse a date-time string Create a range between two dates Calculate the day of the week Extract time components\n\nWhich join in dplyr returns rows that have matches in both data frames?\n\n full_join() left_join() anti_join() inner_join()\n\nWhich join ensures all rows from both data frames are included?\n\n inner_join() full_join() anti_join() left_join()\n\nIf players has 6 rows and teams has 3 matching rows, how many rows will the result of inner_join(players, teams, by = \"team_id\") contain?\n\n 7 3 0 4"
  }
]